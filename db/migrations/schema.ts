import { sqliteTable, AnySQLiteColumn, index, foreignKey, check, integer, text, numeric, real, blob } from "drizzle-orm/sqlite-core"
  import { sql } from "drizzle-orm"

export const kbDocuments = sqliteTable("kb_documents", {
	docId: integer("doc_id").primaryKey({ autoIncrement: true }),
	channelId: text("channel_id").notNull().references(() => clients.channelId),
	sourceType: text("source_type").default("discord_history").notNull(),
	dateRangeStart: integer("date_range_start"),
	dateRangeEnd: integer("date_range_end"),
	ingestedAt: integer("ingested_at").default(sql`(unixepoch())`),
},
(table) => [
	index("idx_kb_documents_channel_ingested").on(table.channelId, table.ingestedAt),
	index("idx_kb_documents_ingested_at").on(table.ingestedAt),
	index("idx_kb_documents_channel").on(table.channelId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const kbChunks = sqliteTable("kb_chunks", {
	chunkId: integer("chunk_id").primaryKey({ autoIncrement: true }),
	docId: integer("doc_id").notNull().references(() => kbDocuments.docId),
	channelId: text("channel_id").notNull(),
	content: text().notNull(),
	embedding: numeric(),
	topicTag: text("topic_tag"),
	authorRole: text("author_role").notNull(),
	messageTimestamp: integer("message_timestamp"),
	metadata: text(),
},
(table) => [
	index("idx_kb_doc_id").on(table.docId),
	index("idx_kb_timestamp").on(table.messageTimestamp),
	index("idx_kb_channel").on(table.channelId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const clients = sqliteTable("clients", {
	channelId: text("channel_id").primaryKey(),
	channelName: text("channel_name").notNull(),
	clientName: text("client_name").notNull(),
	isActive: integer("is_active").default(1),
	createdAt: integer("created_at").default(sql`(unixepoch())`).notNull(),
	avgSentimentScore: real("avg_sentiment_score"),
	churnRiskLevel: text("churn_risk_level").default("low"),
	engagementTrend: text("engagement_trend").default("stable"),
	lastSentiment: text("last_sentiment"),
	updatedAt: integer("updated_at"),
},
(table) => [
	index("idx_clients_active").on(table.isActive),
	index("idx_clients_name").on(table.clientName),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const supportAgents = sqliteTable("support_agents", {
	id: text().default("sql`(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))`").primaryKey(),
	userId: text("user_id"),
	name: text().notNull(),
	type: text().notNull(),
	isActive: integer("is_active").default(1).notNull(),
	config: text(),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
	updatedAt: text("updated_at").default("sql`(datetime('now'))`").notNull(),
},
(table) => [
	index("idx_support_agents_is_active").on(table.isActive),
	index("idx_support_agents_type").on(table.type),
	index("idx_support_agents_user_id").on(table.userId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const supportTickets = sqliteTable("support_tickets", {
	id: text().default("sql`(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))`").primaryKey(),
	userId: text("user_id").notNull(),
	subject: text().notNull(),
	description: text().notNull(),
	status: text().default("open").notNull(),
	priority: text().default("low").notNull(),
	category: text(),
	assignedAgentId: text("assigned_agent_id"),
	metadata: text(),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
	updatedAt: text("updated_at").default("sql`(datetime('now'))`").notNull(),
	closedAt: text("closed_at"),
},
(table) => [
	index("idx_support_tickets_user_id_created").on(table.userId, table.createdAt),
	index("idx_support_tickets_user_id_status").on(table.userId, table.status),
	index("idx_support_tickets_assigned_agent").on(table.assignedAgentId),
	index("idx_support_tickets_category").on(table.category),
	index("idx_support_tickets_priority").on(table.priority),
	index("idx_support_tickets_status").on(table.status),
	index("idx_support_tickets_user_id").on(table.userId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const supportMessages = sqliteTable("support_messages", {
	id: text().default("sql`(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))`").primaryKey(),
	ticketId: text("ticket_id").notNull(),
	senderType: text("sender_type").notNull(),
	senderId: text("sender_id"),
	content: text().notNull(),
	visibility: text().default("public").notNull(),
	aiConfidence: real("ai_confidence"),
	metadata: text(),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
},
(table) => [
	index("idx_support_messages_ticket_created").on(table.ticketId, table.createdAt),
	index("idx_support_messages_ticket_visibility").on(table.ticketId, table.visibility),
	index("idx_support_messages_visibility").on(table.visibility),
	index("idx_support_messages_sender_type").on(table.senderType),
	index("idx_support_messages_ticket_id").on(table.ticketId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const supportKbChunks = sqliteTable("support_kb_chunks", {
	id: text().default("sql`(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))`").primaryKey(),
	documentId: text("document_id").notNull(),
	documentName: text("document_name").notNull(),
	content: text().notNull(),
	embedding: text(),
	metadata: text(),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
	updatedAt: text("updated_at").default("sql`(datetime('now'))`").notNull(),
},
(table) => [
	index("idx_support_kb_chunks_document_name").on(table.documentName),
	index("idx_support_kb_chunks_document_id").on(table.documentId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const pushSubscriptions = sqliteTable("push_subscriptions", {
	id: text().default("sql`(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))`").primaryKey(),
	userId: text("user_id").notNull(),
	endpoint: text().notNull(),
	p256Dh: text().notNull(),
	auth: text().notNull(),
	userAgent: text("user_agent"),
	isActive: integer("is_active").default(1).notNull(),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
	updatedAt: text("updated_at").default("sql`(datetime('now'))`").notNull(),
},
(table) => [
	index("idx_push_subscriptions_user_id_active").on(table.userId, table.isActive),
	index("idx_push_subscriptions_is_active").on(table.isActive),
	index("idx_push_subscriptions_user_id").on(table.userId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const riskRadar = sqliteTable("risk_radar", {
	id: integer().primaryKey({ autoIncrement: true }),
	channelId: text("channel_id").notNull().references(() => clients.channelId, { onDelete: "cascade" } ),
	lastClientMsgAt: integer("last_client_msg_at"),
	lastTeamReplyAt: integer("last_team_reply_at"),
	inactivityDays: integer("inactivity_days").default(0),
	riskStatus: text("risk_status").default("HEALTHY"),
	updatedAt: integer("updated_at").default(sql`(unixepoch())`).notNull(),
},
(table) => [
	index("idx_radar_channel_status").on(table.channelId, table.riskStatus),
	index("risk_inactivity_status_idx").on(table.inactivityDays, table.riskStatus),
	index("idx_risk_radar_updated_at").on(table.updatedAt),
	index("idx_risk_radar_inactivity_days").on(table.inactivityDays),
	index("idx_risk_radar_last_client_msg_at").on(table.lastClientMsgAt),
	index("idx_risk_radar_risk_status").on(table.riskStatus),
	index("idx_risk_radar_channel_id").on(table.channelId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const csmResponseAnalytics = sqliteTable("csm_response_analytics", {
	id: integer().primaryKey({ autoIncrement: true }),
	channelId: text("channel_id").notNull().references(() => clients.channelId),
	queryId: integer("query_id").references(() => queryBoard.id),
	queryTimestamp: integer("query_timestamp").notNull(),
	responseTimestamp: integer("response_timestamp"),
	responseTimeSeconds: integer("response_time_seconds"),
	resolutionTimeSeconds: integer("resolution_time_seconds"),
	responderUserId: text("responder_user_id"),
	responderUsername: text("responder_username"),
	responseUsefulness: text("response_usefulness"),
	responseProfessionalism: text("response_professionalism"),
	responseClarity: real("response_clarity"),
	containsLoomLink: integer("contains_loom_link").default(0),
	loomUrl: text("loom_url"),
	loomEffectiveness: text("loom_effectiveness"),
	overallQualityScore: real("overall_quality_score"),
	aiAssessmentRaw: text("ai_assessment_raw"),
	createdAt: integer("created_at").default(sql`(unixepoch())`).notNull(),
	updatedAt: integer("updated_at").default(sql`(unixepoch())`).notNull(),
	effectivenessDetail: text("effectiveness_detail"),
	effectivenessLevel: text("effectiveness_level").default("sql`("relevant")`"),
	customerFirstLanguage: text("customer_first_language").default("sql`("transactional")`"),
	fiveStarRating: text("five_star_rating"),
	confidenceStatement: text("confidence_statement"),
	confidenceLevel: text("confidence_level").default("sql`("mid")`"),
},
(table) => [
	index("csm_quality_time_idx").on(table.overallQualityScore, table.queryTimestamp),
	index("csm_responder_time_idx").on(table.responderUserId, table.queryTimestamp),
	index("csm_channel_time_idx").on(table.channelId, table.queryTimestamp),
	index("idx_csm_response_timestamp").on(table.queryTimestamp),
	index("idx_csm_response_responder").on(table.responderUserId),
	index("idx_csm_response_channel").on(table.channelId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const customerSentiment = sqliteTable("customer_sentiment", {
	id: integer().primaryKey({ autoIncrement: true }),
	channelId: text("channel_id").notNull().references(() => clients.channelId),
	messageId: text("message_id").notNull(),
	sentimentType: text("sentiment_type").notNull(),
	sentimentScore: real("sentiment_score"),
	isComplaint: integer("is_complaint").default(0),
	isIssueReport: integer("is_issue_report").default(0),
	isFeedback: integer("is_feedback").default(0),
	isPauseRequest: integer("is_pause_request").default(0),
	isPaymentIssue: integer("is_payment_issue").default(0),
	isCancellationSignal: integer("is_cancellation_signal").default(0),
	isDisengagement: integer("is_disengagement").default(0),
	isFrustration: integer("is_frustration").default(0),
	isConfusion: integer("is_confusion").default(0),
	engagementLevel: text("engagement_level"),
	messageContent: text("message_content").notNull(),
	aiSummary: text("ai_summary"),
	keywords: text(),
	requiresImmediateAction: integer("requires_immediate_action").default(0),
	suggestedAction: text("suggested_action"),
	aiAnalysisRaw: text("ai_analysis_raw"),
	authorId: text("author_id"),
	authorUsername: text("author_username"),
	messageTimestamp: integer("message_timestamp").notNull(),
	discordMsgLink: text("discord_msg_link"),
	createdAt: integer("created_at").default(sql`(unixepoch())`).notNull(),
	confidenceLevel: text("confidence_level").default("sql`("mid")`"),
},
(table) => [
	index("idx_sentiment_channel_complaint").on(table.channelId, table.isComplaint),
	index("sentiment_churn_signals_idx").on(table.channelId, table.isPauseRequest, table.isPaymentIssue, table.isCancellationSignal, table.messageTimestamp),
	index("sentiment_type_timestamp_idx").on(table.sentimentType, table.messageTimestamp),
	index("sentiment_channel_timestamp_idx").on(table.channelId, table.messageTimestamp),
	index("idx_sentiment_engagement").on(table.engagementLevel),
	index("idx_sentiment_timestamp").on(table.messageTimestamp),
	index("idx_sentiment_churn_signals").on(table.isPauseRequest, table.isPaymentIssue, table.isCancellationSignal),
	index("idx_sentiment_type").on(table.sentimentType),
	index("idx_sentiment_channel").on(table.channelId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const dailyAnalyticsSummary = sqliteTable("daily_analytics_summary", {
	id: integer().primaryKey({ autoIncrement: true }),
	channelId: text("channel_id").notNull().references(() => clients.channelId),
	date: text().notNull(),
	totalClientMessages: integer("total_client_messages").default(0),
	totalTeamMessages: integer("total_team_messages").default(0),
	totalQueries: integer("total_queries").default(0),
	queriesResolved: integer("queries_resolved").default(0),
	avgResponseTimeSeconds: integer("avg_response_time_seconds"),
	minResponseTimeSeconds: integer("min_response_time_seconds"),
	maxResponseTimeSeconds: integer("max_response_time_seconds"),
	avgResolutionTimeSeconds: integer("avg_resolution_time_seconds"),
	avgUsefulnessScore: real("avg_usefulness_score"),
	avgProfessionalismScore: real("avg_professionalism_score"),
	avgClarityScore: real("avg_clarity_score"),
	avgOverallQuality: real("avg_overall_quality"),
	loomsSent: integer("looms_sent").default(0),
	loomsEffective: integer("looms_effective").default(0),
	positiveMessages: integer("positive_messages").default(0),
	neutralMessages: integer("neutral_messages").default(0),
	negativeMessages: integer("negative_messages").default(0),
	frustratedMessages: integer("frustrated_messages").default(0),
	churnSignalsCount: integer("churn_signals_count").default(0),
	complaintsCount: integer("complaints_count").default(0),
	engagementScore: real("engagement_score"),
	createdAt: integer("created_at").default(sql`(unixepoch())`).notNull(),
	updatedAt: integer("updated_at").default(sql`(unixepoch())`).notNull(),
},
(table) => [
	index("summary_date_channel_idx").on(table.date, table.channelId),
	index("idx_daily_summary_date").on(table.date),
	index("idx_daily_summary_channel_date").on(table.channelId, table.date),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const questions = sqliteTable("questions", {
	id: integer().primaryKey({ autoIncrement: true }),
	channelId: text("channel_id").notNull().references(() => clients.channelId),
	content: text().notNull(),
	aiSummary: text("ai_summary"),
	type: text().notNull(),
	urgency: text().notNull(),
	status: text().default("open"),
	priority: text(),
	discordMsgLink: text("discord_msg_link").notNull(),
	resolvedById: text("resolved_by_id"),
	responseTimeSeconds: integer("response_time_seconds"),
	resolutionTimeSeconds: integer("resolution_time_seconds"),
	responseQualityScore: real("response_quality_score"),
	firstResponseAt: integer("first_response_at"),
	resolvedAt: integer("resolved_at"),
	createdAt: integer("created_at").default(sql`(unixepoch())`).notNull(),
	updatedAt: integer("updated_at").default(sql`(unixepoch())`).notNull(),
},
(table) => [
	index("idx_questions_channel_created").on(table.channelId, table.createdAt),
	index("questions_created_status_idx").on(table.createdAt, table.status),
	index("questions_channel_status_created_idx").on(table.channelId, table.status, table.createdAt),
	index("idx_questions_created_at").on(table.createdAt),
	index("idx_questions_urgency").on(table.urgency),
	index("idx_questions_type").on(table.type),
	index("idx_questions_status").on(table.status),
	index("idx_questions_channel").on(table.channelId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const topIssues = sqliteTable("top_issues", {
	id: integer().primaryKey({ autoIncrement: true }),
	topicCategory: text("topic_category").notNull(),
	topicKeywords: text("topic_keywords"),
	topicEmbedding: blob("topic_embedding"),
	canonicalQuestion: text("canonical_question").notNull(),
	sampleQuestions: text("sample_questions"),
	occurrenceCount: integer("occurrence_count").default(1),
	firstSeenAt: integer("first_seen_at").default(sql`(unixepoch())`).notNull(),
	lastSeenAt: integer("last_seen_at").default(sql`(unixepoch())`).notNull(),
	affectedChannels: text("affected_channels"),
	uniqueClientsCount: integer("unique_clients_count").default(1),
	trainingMaterialExists: integer("training_material_exists").default(0),
	trainingRecommendation: text("training_recommendation"),
	priority: text().default("medium"),
	isAddressed: integer("is_addressed").default(0),
	addressedAt: integer("addressed_at"),
	addressedNotes: text("addressed_notes"),
	createdAt: integer("created_at").default(sql`(unixepoch())`).notNull(),
	updatedAt: integer("updated_at").default(sql`(unixepoch())`).notNull(),
},
(table) => [
	index("issues_priority_count_idx").on(table.priority, table.occurrenceCount, table.lastSeenAt),
	index("idx_top_issues_unaddressed").on(table.isAddressed),
	index("idx_top_issues_priority").on(table.priority),
	index("idx_top_issues_count").on(table.occurrenceCount),
	index("idx_top_issues_category").on(table.topicCategory),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const topissuescomparisonJob = sqliteTable("topissuescomparison-job", {
	id: integer().primaryKey({ autoIncrement: true }),
	issueId: integer("issue_id").notNull().references(() => topIssues.id),
	channelId: text("channel_id").notNull().references(() => clients.channelId),
	questionId: integer("question_id").references(() => questions.id),
	messageId: text("message_id").notNull(),
	messageContent: text("message_content").notNull(),
	similarityScore: real("similarity_score"),
	messageTimestamp: integer("message_timestamp").notNull(),
	discordMsgLink: text("discord_msg_link"),
	createdAt: integer("created_at").default(sql`(unixepoch())`).notNull(),
},
(table) => [
	index("idx_topissuescomparison_message").on(table.messageId),
	index("idx_topissuescomparison_question").on(table.questionId),
	index("idx_topissuescomparison_channel").on(table.channelId),
	index("idx_topissuescomparison_issue").on(table.issueId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const looms = sqliteTable("looms", {
	id: integer().primaryKey({ autoIncrement: true }),
	channelId: text("channel_id").notNull().references(() => clients.channelId),
	messageId: text("message_id").notNull(),
	loomUrl: text("loom_url").notNull(),
	loomId: text("loom_id"),
	queryContext: text("query_context"),
	questionId: integer("question_id").references(() => questions.id),
	senderUserId: text("sender_user_id").notNull(),
	senderUsername: text("sender_username"),
	clientResponseAfter: text("client_response_after"),
	wasHelpful: integer("was_helpful"),
	clientFollowupQuestions: integer("client_followup_questions").default(0),
	sentAt: integer("sent_at").notNull(),
	clientAcknowledgedAt: integer("client_acknowledged_at"),
	discordMsgLink: text("discord_msg_link"),
	createdAt: integer("created_at").default(sql`(unixepoch())`).notNull(),
},
(table) => [
	index("looms_channel_time_idx").on(table.channelId, table.createdAt),
	index("idx_looms_question").on(table.questionId),
	index("idx_looms_timestamp").on(table.sentAt),
	index("idx_looms_sender").on(table.senderUserId),
	index("idx_looms_channel").on(table.channelId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

export const outboundLinks = sqliteTable("outbound_links", {
	id: integer().primaryKey({ autoIncrement: true }),
	channelId: text("channel_id").notNull().references(() => clients.channelId),
	messageId: text("message_id").notNull(),
	url: text().notNull(),
	linkType: text("link_type"),
	isInternal: integer("is_internal").default(0),
	questionId: integer("question_id").references(() => questions.id),
	issueId: integer("issue_id").references(() => topIssues.id),
	senderUserId: text("sender_user_id"),
	senderUsername: text("sender_username"),
	context: text(),
	wasClicked: integer("was_clicked").default(0),
	clientResponseAfter: text("client_response_after"),
	extractedAt: integer("extracted_at").default(sql`(unixepoch())`).notNull(),
	discordMsgLink: text("discord_msg_link"),
	createdAt: integer("created_at").default(sql`(unixepoch())`).notNull(),
},
(table) => [
	index("links_channel_type_time_idx").on(table.channelId, table.linkType, table.createdAt),
	index("idx_outbound_timestamp").on(table.extractedAt),
	index("idx_outbound_sender").on(table.senderUserId),
	index("idx_outbound_url").on(table.url),
	index("idx_outbound_issue").on(table.issueId),
	index("idx_outbound_question").on(table.questionId),
	index("idx_outbound_channel").on(table.channelId),
	check("kb_chunks_check_1", sql`author_role IN ('client', 'team'`),
	check("support_agents_check_2", sql`type IN ('human', 'ai'`),
	check("support_tickets_check_3", sql`status IN ('open', 'pending', 'closed'`),
	check("support_tickets_check_4", sql`priority IN ('low', 'high'`),
	check("support_tickets_check_5", sql`category IN ('bug', 'feature', 'question', 'other'`),
	check("support_messages_check_6", sql`sender_type IN ('user', 'human_agent', 'ai_agent'`),
	check("support_messages_check_7", sql`visibility IN ('public', 'internal'`),
	check("risk_radar_check_8", sql`risk_status IN ('HEALTHY', 'STAGNANT', 'AT_RISK', 'CHURNED'`),
]);

